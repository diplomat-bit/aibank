# coding: utf-8
"""
TaxStatement_Digital_Orchestration

Account Documents APIs Version 2.0. These APIs are used by Citi Partners to retrieve tax documents for existing Accounts from various regions.

OpenAPI spec version: 1.0.0
Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import datetime
import json
import mimetypes
import os
import re
import tempfile
from multiprocessing.pool import ThreadPool

import six
import swagger_client.models
from six.moves.urllib.parse import quote
from swagger_client import rest
from swagger_client.configuration import Configuration


class ApiClient(object):
    """Generic API client for Swagger client library builds."""

    PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
    NATIVE_TYPES_MAPPING = {
        "int": int,
        "long": int if six.PY3 else long,  # noqa: F821
        "float": float,
        "str": str,
        "bool": bool,
        "date": datetime.date,
        "datetime": datetime.datetime,
        "object": object,
    }

    def __init__(self, configuration=None, header_name=None, header_value=None, cookie=None):
        if configuration is None:
            configuration = Configuration()
        self.configuration = configuration
        self.pool = ThreadPool()
        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        self.user_agent = "Swagger-Codegen/1.0.0/python"

    def __del__(self):
        self.pool.close()
        self.pool.join()

    @property
    def user_agent(self):
        return self.default_headers["User-Agent"]

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers["User-Agent"] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value

    # ----------------------------
    # Serialization / Deserialization
    # ----------------------------

    def sanitize_for_serialization(self, obj):
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]
        elif isinstance(obj, tuple):
            return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        if isinstance(obj, dict):
            obj_dict = obj
        else:
            obj_dict = {
                obj.attribute_map[attr]: getattr(obj, attr)
                for attr, _ in six.iteritems(obj.swagger_types)
                if getattr(obj, attr) is not None
            }

        return {k: self.sanitize_for_serialization(v) for k, v in six.iteritems(obj_dict)}

    def deserialize(self, response, response_type):
        if response_type == "file":
            return self.__deserialize_file(response)
        try:
            data = json.loads(response.data)
        except ValueError:
            data = response.data
        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        if data is None:
            return None
        if isinstance(klass, str):
            if klass.startswith("list["):
                sub_kls = re.match(r"list\[(.*)\]", klass).group(1)
                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]
            if klass.startswith("dict("):
                sub_kls = re.match(r"dict\(([^,]*), (.*)\)", klass).group(2)
                return {k: self.__deserialize(v, sub_kls) for k, v in six.iteritems(data)}
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(swagger_client.models, klass)
        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def __deserialize_primitive(self, data, klass):
        try:
            return klass(data)
        except (UnicodeEncodeError, TypeError):
            return six.text_type(data)

    def __deserialize_object(self, value):
        return value

    def __deserialize_date(self, string):
        try:
            from dateutil.parser import parse
            return parse(string).date()
        except (ImportError, ValueError):
            return string

    def __deserialize_datetime(self, string):
        try:
            from dateutil.parser import parse
            return parse(string)
        except (ImportError, ValueError):
            return string

    def __hasattr(self, obj, name):
        return name in obj.__class__.__dict__

    def __deserialize_model(self, data, klass):
        if not klass.swagger_types and not self.__hasattr(klass, "get_real_child_model"):
            return data
        kwargs = {}
        if klass.swagger_types is not None:
            for attr, attr_type in six.iteritems(klass.swagger_types):
                if data is not None and klass.attribute_map[attr] in data and isinstance(data, (list, dict)):
                    value = data[klass.attribute_map[attr]]
                    kwargs[attr] = self.__deserialize(value, attr_type)
        instance = klass(**kwargs)
        if isinstance(instance, dict) and klass.swagger_types is not None and isinstance(data, dict):
            for key, value in data.items():
                if key not in klass.swagger_types:
                    instance[key] = value
        if self.__hasattr(instance, "get_real_child_model"):
            klass_name = instance.get_real_child_model(data)
            if klass_name:
                instance = self.__deserialize(data, klass_name)
        return instance

    def __deserialize_file(self, response):
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)
        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?', content_disposition).group(1)
            path = os.path.join(os.path.dirname(path), filename)
        response_data = response.data
        with open(path, "wb") as f:
            if isinstance(response_data, str):
                response_data = response_data.encode("utf-8")
            f.write(response_data)
        return path

    # ----------------------------
    # HTTP Request Methods
    # ----------------------------

    def __call_api(self, resource_path, method, path_params=None, query_params=None, header_params=None,
                   body=None, post_params=None, files=None, response_type=None, auth_settings=None,
                   _return_http_data_only=None, collection_formats=None, _preload_content=True,
                   _request_timeout=None):
        config = self.configuration

        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params["Cookie"] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(self.parameters_to_tuples(header_params, collection_formats))

        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(path_params, collection_formats)
            for k, v in path_params:
                resource_path = resource_path.replace("{%s}" % k, quote(str(v), safe=config.safe_chars_for_path_param))

        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            query_params = self.parameters_to_tuples(query_params, collection_formats)

        if post_params or files:
            post_params = self.prepare_post_parameters(post_params, files)
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(post_params, collection_formats)

        self.update_params_for_auth(header_params, query_params, auth_settings)

        if body:
            body = self.sanitize_for_serialization(body)

        url = self.configuration.host + resource_path
        response_data = self.request(method, url, query_params=query_params, headers=header_params,
                                     post_params=post_params, body=body,
                                     _preload_content=_preload_content, _request_timeout=_request_timeout)
        self.last_response = response_data

        return_data = response_data
        if _preload_content:
            return_data = self.deserialize(response_data, response_type) if response_type else None

        if _return_http_data_only:
            return return_data
        return return_data, response_data.status, response_data.getheaders()

    def call_api(self, resource_path, method, path_params=None, query_params=None, header_params=None,
                 body=None, post_params=None, files=None, response_type=None, auth_settings=None,
                 async_req=None, _return_http_data_only=None, collection_formats=None,
                 _preload_content=True, _request_timeout=None):
        if not async_req:
            return self.__call_api(resource_path, method, path_params, query_params, header_params,
                                   body, post_params, files, response_type, auth_settings,
                                   _return_http_data_only, collection_formats, _preload_content,
                                   _request_timeout)
        else:
            return self.pool.apply_async(self.__call_api, (resource_path, method, path_params, query_params, header_params,
                                                           body, post_params, files, response_type, auth_settings,
                                                           _return_http_data_only, collection_formats, _preload_content,
                                                           _request_timeout))

    def request(self, method, url, query_params=None, headers=None, post_params=None, body=None,
                _preload_content=True, _request_timeout=None):
        if method == "GET":
            return self.rest_client.GET(url, query_params=query_params, headers=headers,
                                        _preload_content=_preload_content, _request_timeout=_request_timeout)
        elif method == "POST":
            return self.rest_client.POST(url, query_params=query_params, headers=headers,
                                         post_params=post_params, body=body,
                                         _preload_content=_preload_content, _request_timeout=_request_timeout)
        elif method == "PUT":
            return self.rest_client.PUT(url, query_params=query_params, headers=headers,
                                        post_params=post_params, body=body,
                                        _preload_content=_preload_content, _request_timeout=_request_timeout)
        elif method == "PATCH":
            return self.rest_client.PATCH(url, query_params=query_params, headers=headers,
                                          post_params=post_params, body=body,
                                          _preload_content=_preload_content, _request_timeout=_request_timeout)
        elif method == "DELETE":
            return self.rest_client.DELETE(url, query_params=query_params, headers=headers,
                                           body=body, _preload_content=_preload_content, _request_timeout=_request_timeout)
        elif method == "HEAD":
            return self.rest_client.HEAD(url, query_params=query_params, headers=headers,
                                         _preload_content=_preload_content, _request_timeout=_request_timeout)
        elif method == "OPTIONS":
            return self.rest_client.OPTIONS(url, query_params=query_params, headers=headers,
                                            post_params=post_params, body=body,
                                            _preload_content=_preload_content, _request_timeout=_request_timeout)
        else:
            raise ValueError("http method must be `GET`, `HEAD`, `OPTIONS`, `POST`, `PATCH`, `PUT` or `DELETE`.")

    def parameters_to_tuples(self, params, collection_formats):
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in six.iteritems(params) if isinstance(params, dict) else params:
            if k in collection_formats:
                fmt = collection_formats[k]
                if fmt == "multi":
                    new_params.extend((k, value) for value in v)
                else:
                    delim = {"ssv": " ", "tsv": "\t", "pipes": "|", "csv": ","}.get(fmt, ",")
                    new_params.append((k, delim.join(str(x) for x in v)))
            else:
                new_params.append((k, v))
        return new_params

    def prepare_post_parameters(self, post_params=None, files=None):
        params = post_params or []
        if files:
            for k, v in six.iteritems(files):
                if not v:
                    continue
                for n in v if isinstance(v, list) else [v]:
                    with open(n, "rb") as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = mimetypes.guess_type(filename)[0] or "application/octet-stream"
                        params.append((k, (filename, filedata, mimetype)))
        return params

    def select_header_accept(self, accepts):
        if not accepts:
            return
        accepts = [x.lower() for x in accepts]
        return "application/json" if "application/json" in accepts else ", ".join(accepts)

    def select_header_content_type(self, content_types):
        if not content_types:
            return "application/json"
        content_types = [x.lower() for x in content_types]
        return "application/json" if "application/json" in content_types or "*/*" in content_types else content_types[0]

    def update_params_for_auth(self, headers, querys, auth_settings):
        if not auth_settings:
            return
        for auth in auth_settings:
            auth_setting = self.configuration.auth_settings().get(auth)
            if auth_setting and auth_setting.get("value"):
                if auth_setting["in"] == "header":
                    headers[auth_setting["key"]] = auth_setting["value"]
                elif auth_setting["in"] == "query":
                    querys.append((auth_setting["key"], auth_setting["value"]))
                else:
                    raise ValueError("Authentication token must be in `query` or `header`")